{"id":"node_modules/graphql-language-service-parser/dist/onlineParser.js","dependencies":[{"name":"/Users/lindsayj/Documents/dev/css-vs-js/node_modules/graphql-language-service-parser/dist/onlineParser.js.map","includedInParent":true,"mtime":499162500000},{"name":"/Users/lindsayj/Documents/dev/css-vs-js/package.json","includedInParent":true,"mtime":1572464414593},{"name":"/Users/lindsayj/Documents/dev/css-vs-js/node_modules/graphql-language-service-parser/package.json","includedInParent":true,"mtime":1572464394178},{"name":"./Rules","loc":{"line":3,"column":24},"parent":"/Users/lindsayj/Documents/dev/css-vs-js/node_modules/graphql-language-service-parser/dist/onlineParser.js","resolved":"/Users/lindsayj/Documents/dev/css-vs-js/node_modules/graphql-language-service-parser/dist/Rules.js"}],"generated":{"js":"\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst Rules_1 = require(\"./Rules\");\nfunction onlineParser(options = {\n    eatWhitespace: stream => stream.eatWhile(Rules_1.isIgnored),\n    lexRules: Rules_1.LexRules,\n    parseRules: Rules_1.ParseRules,\n    editorConfig: {},\n}) {\n    return {\n        startState() {\n            const initialState = {\n                level: 0,\n                step: 0,\n                name: null,\n                kind: null,\n                type: null,\n                rule: null,\n                needsSeperator: false,\n                prevState: null,\n            };\n            pushRule(options.parseRules, initialState, 'Document');\n            return initialState;\n        },\n        token(stream, state) {\n            return getToken(stream, state, options);\n        },\n    };\n}\nexports.default = onlineParser;\nfunction getToken(stream, state, options) {\n    const { lexRules, parseRules, eatWhitespace, editorConfig } = options;\n    if (state.rule && state.rule.length === 0) {\n        popRule(state);\n    }\n    else if (state.needsAdvance) {\n        state.needsAdvance = false;\n        advanceRule(state, true);\n    }\n    if (stream.sol()) {\n        const tabSize = (editorConfig && editorConfig.tabSize) || 2;\n        state.indentLevel = Math.floor(stream.indentation() / tabSize);\n    }\n    if (eatWhitespace(stream)) {\n        return 'ws';\n    }\n    const token = lex(lexRules, stream);\n    if (!token) {\n        const matchedSomething = stream.match(/\\S+/);\n        if (!matchedSomething) {\n            stream.match(/\\s/);\n        }\n        pushRule(SpecialParseRules, state, 'Invalid');\n        return 'invalidchar';\n    }\n    if (token.kind === 'Comment') {\n        pushRule(SpecialParseRules, state, 'Comment');\n        return 'comment';\n    }\n    const backupState = assign({}, state);\n    if (token.kind === 'Punctuation') {\n        if (/^[{([]/.test(token.value)) {\n            if (state.indentLevel !== undefined) {\n                state.levels = (state.levels || []).concat(state.indentLevel + 1);\n            }\n        }\n        else if (/^[})\\]]/.test(token.value)) {\n            const levels = (state.levels = (state.levels || []).slice(0, -1));\n            if (state.indentLevel) {\n                if (levels.length > 0 &&\n                    levels[levels.length - 1] < state.indentLevel) {\n                    state.indentLevel = levels[levels.length - 1];\n                }\n            }\n        }\n    }\n    while (state.rule) {\n        let expected = typeof state.rule === 'function'\n            ? state.step === 0\n                ? state.rule(token, stream)\n                : null\n            : state.rule[state.step];\n        if (state.needsSeperator) {\n            expected = expected && expected.separator;\n        }\n        if (expected) {\n            if (expected.ofRule) {\n                expected = expected.ofRule;\n            }\n            if (typeof expected === 'string') {\n                pushRule(parseRules, state, expected);\n                continue;\n            }\n            if (expected.match && expected.match(token)) {\n                if (expected.update) {\n                    expected.update(state, token);\n                }\n                if (token.kind === 'Punctuation') {\n                    advanceRule(state, true);\n                }\n                else {\n                    state.needsAdvance = true;\n                }\n                return expected.style;\n            }\n        }\n        unsuccessful(state);\n    }\n    assign(state, backupState);\n    pushRule(SpecialParseRules, state, 'Invalid');\n    return 'invalidchar';\n}\nfunction assign(to, from) {\n    const keys = Object.keys(from);\n    for (let i = 0; i < keys.length; i++) {\n        to[keys[i]] = from[keys[i]];\n    }\n    return to;\n}\nconst SpecialParseRules = {\n    Invalid: [],\n    Comment: [],\n};\nfunction pushRule(rules, state, ruleKind) {\n    if (!rules[ruleKind]) {\n        throw new TypeError('Unknown rule: ' + ruleKind);\n    }\n    state.prevState = { ...state };\n    state.kind = ruleKind;\n    state.name = null;\n    state.type = null;\n    state.rule = rules[ruleKind];\n    state.step = 0;\n    state.needsSeperator = false;\n}\nfunction popRule(state) {\n    if (!state.prevState) {\n        return;\n    }\n    state.kind = state.prevState.kind;\n    state.name = state.prevState.name;\n    state.type = state.prevState.type;\n    state.rule = state.prevState.rule;\n    state.step = state.prevState.step;\n    state.needsSeperator = state.prevState.needsSeperator;\n    state.prevState = state.prevState.prevState;\n}\nfunction advanceRule(state, successful) {\n    if (isList(state) && state.rule) {\n        const step = state.rule[state.step];\n        if (step.separator) {\n            const separator = step.separator;\n            state.needsSeperator = !state.needsSeperator;\n            if (!state.needsSeperator && separator.ofRule) {\n                return;\n            }\n        }\n        if (successful) {\n            return;\n        }\n    }\n    state.needsSeperator = false;\n    state.step++;\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.step < state.rule.length)) {\n        popRule(state);\n        if (state.rule) {\n            if (isList(state)) {\n                if (state.rule && state.rule[state.step].separator) {\n                    state.needsSeperator = !state.needsSeperator;\n                }\n            }\n            else {\n                state.needsSeperator = false;\n                state.step++;\n            }\n        }\n    }\n}\nfunction isList(state) {\n    const step = Array.isArray(state.rule) &&\n        typeof state.rule[state.step] !== 'string' &&\n        state.rule[state.step];\n    return step && step.isList;\n}\nfunction unsuccessful(state) {\n    while (state.rule &&\n        !(Array.isArray(state.rule) && state.rule[state.step].ofRule)) {\n        popRule(state);\n    }\n    if (state.rule) {\n        advanceRule(state, false);\n    }\n}\nfunction lex(lexRules, stream) {\n    const kinds = Object.keys(lexRules);\n    for (let i = 0; i < kinds.length; i++) {\n        const match = stream.match(lexRules[kinds[i]]);\n        if (match && match instanceof Array) {\n            return { kind: kinds[i], value: match[0] };\n        }\n    }\n}\n"},"sourceMaps":{"js":{"version":3,"file":"onlineParser.js","sourceRoot":"","sources":["../src/onlineParser.ts"],"names":[],"mappings":"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","sourcesContent":[null]}},"error":null,"hash":"0a72a12e2937a387cb95c3e708af0d45","cacheData":{"env":{}}}